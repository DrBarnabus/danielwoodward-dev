---
title: 'How I built my Personal Blog with NextJS 13, Vercel and Contentlayer - Part 1'
summary: 'The process of how I built my new Personal Blog with NextJS 13, Vercel and Contentlayer. All the steps to get a basic site up and running and how to deploy it for free!'
publishedDate: '2023-04-23'
topic: NextJS
tags:
  - NextJS
  - Vercel
  - Contentlayer
  - AppDirectory
  - Markdown
  - MDX
  - Blog
  - React
  - TypeScript
  - SSG
---

Over the past week or so in my spare time I've been busy building my new Personal Blog Site (which you are currently looking at üòâ)
using [Next.js 13][nextjs-docs]'s new App Directory, [Contentlayer][contentlayer]'s easy to setup tooling for working
with Markdown/[MDX][mdx] and deployed it with just a few clicks to [Vercel][vercel]'s amazing platform completely for **free!**

Now it's _mostly finished_, only been working on tweaks and enhancements, and I've tested it fully by posting my first post. I've
decided to write about how I got this setup in around **5 hours** worth of work over a weekend and how you could do the same.
I'll cover some questions such as; Why the hell I would build my blog from scratch instead of using one of the countless offerings
out there and Why I chose the technologies I did to build it?

If you aren't interesting in the background or the reasons for choosing the specific technologies used, you can
[skip to the good bit](#getting-started)

{/* prettier-ignore */}
<TableOfContents>
- [Why build a blog from scratch in the first place?](#why-build-a-blog-from-scratch-in-the-first-place)
- [Why did I choose the technologies I have?](#why-did-i-choose-the-technologies-i-have)
  - [Why NextJS?](#why-nextjs)
  - [Why Contentlayer?](#why-contentlayer)
  - [Why Vercel?](#why-vercel)
- [Getting started](#getting-started)
</TableOfContents>

This is the first part of a series of posts on this topic, as and when subsequent parts are available I will add the links here.

# Why build a blog from scratch in the first place?

![{{ "width": 480, "height": 270, "alt": "A person falling over at a Petrol Station with Text I can do it myself" }}](/images/memes/i-can-do-it-myself.gif)

Why would you build a blog from scratch when there are [countless][forbes-best-blogging-platforms] existing platforms that would have
required a single click to setup? And it's an **extremely valid** question, even after spending my time building this site, I am
still planning on re-publishing my content on [Medium][my-medium-profile] to reach a larger audience. But there are a few reasons why
I inevitably decided to build my own blog from scratch:

- **I'm just that type of person:** Being a Software Developer, and a naturally inquisitive person, I like to know how the tools I'm
  using work "under the hood". I've never been satisfied with just using something because it works, I always like to know how it works
  and more importantly why it works the way that it does.
- **The challenge and opportunity to learn:** Building a blog that statically generates content from Markdown requires quite a lot of effort
  to get setup and even more so if you want it to work properly and look nice while it's doing it. But to me that's part of the fun, the
  opportunity to expose myself to and learn new tools/frameworks that I might have otherwise overlooked because it wasn't for a "hobby
  project".
- **Full control and autonomy:** One of if not the most significant advantages of building your own personal website/blog from scratch is
  that you have 100% full control and autonomy over it. How it looks, how it works, how it's deployed and the content that's on it is
  completely up to you as you are the complete owner of all the code and content. You can add/remove features and do literally anything
  you set your mind to, if this is something you want I would highly recommend building from scratch, especially if you are quick picky.
- **Not locked into a specific platform:** By building and hosting everything yourself it means you aren't tied into a specific platform.
  You are free to move your site anytime you want, host it anywhere you want and quite honestly do anything you want to do with it!
- **Customization:** As you aren't using a specific platform/template you can do literally anything with it and make the site completely
  your own. There are literally 0 restrictions on what you can do, as long as it's possible with current web technology of course. If you
  do this right you can make your site truly unique!

There are of course some downsides to building your blog from scratch:

- **Time investment:** One of the main downsides is the time investment, your time is valuable and if you have to spend time that you
  would otherwise have spent writing content for your blog on writing features that come standard with "out of the box" platforms then
  that could be seen as a waste of time. Building features from scratch to a good quality takes a lot of time so you need to be happy
  with the trade off that this represents (Customization + Quality = >TimeInvestment).
- **Hosting charges:** At least with the initial deployment of this blog the hosting charges are ¬£0/m, but with growth which anyone
  starting their blogging endeavour of course hopes for then this could raise as you reach your allocated resource limits. These types
  of scaling pain points affect any type of site/app on the web, so you will need to have a clear plan to deal with these.
- **Discoverability:** Writing articles that nobody can find is enough to put anybody off when it comes to the time investment of writing
  content for any site. You'll have to build an audience from scratch which can be incredibly daunting and demoralising, but there are
  ways to combat this such as re-posting on existing sites such as [Medium][my-medium-profile] to benefit from it's existing search reputation.

Of course there are positives and negatives to everything you do, I have detailed these here just so you know what you are getting into if
you decide to follow this path.

# Why did I choose the technologies I have?

Onto our second topic for this post, why choose the specific technologies I have to build this blog? There are a number of building blocks
you could use to implement any application, some are right for the job and some of them just plain are not.

![{{ "width": 300, "height": 302, "alt": "That's right! It goes in the square hole" }}](/images/memes/the-square-hole.gif)

So I would like to quickly go through the main building blocks of the blog; NextJS, ContentLayer and Vercel.

## Why NextJS?

[Next.js][nextjs-docs] and more specifically [v13][nextjs-beta] has been almost somewhat of a spiritual awakening for me into the world of
React, SSG, Server Side Rendering and Edge. I had dabbled with Next.js before but never quite connected with it on the level that I needed
to for me to be comfortable using it in anything serious, or even using it in hobby projects. Next.js 13 changed that for me with the
introduction of the [App Directory][nextjs-beta-app], this new structure along with the introduction of React Server Components gave me the
push I needed to properly investigate Next.js and dive into creating some Hobby Projects with it. And after experimenting with it's new mental
model for creating apps I just instantly fell in love ‚ù§Ô∏è. (As a side note, I know it's Next.js but I just prefer writing it as NextJS ü§∑)

![{{ "width": 450, "height": 252, "alt": "Homelander saying it was perfect" }}](/images/memes/perfect-homelander.gif)

One of the strong points of NextJS is that it can statically generate pages at build time, which is great for our use case as it's going to
almost entirely consist of static content. Any content that I can't statically generate, such as OpenGraph images, I'm planning on deploying
as either serverless or edge compute by virtue of Next's integration with it's creator [Vercel][vercel].

## Why Contentlayer?

[Contentlayer][contentlayer] is a Content SDK for validating, transforming and working with your content in a type-safe format that you can
easily import into your application. For more information about contentlayer I would suggest reading their [blog post][contentlayer-post].
Put simply this package made it trivial to build your content including Markdown/MDX into an easily consumable strongly typed format for
use in NextJS. I've had some limited experience with content generation before with some static site generators (mainly for documentation
sites), but I have to say without a doubt using contentlayer has been game changing and demonstrates the accessibility tools in the modern
web-dev ecosystem have made the experience.

## Why Vercel?

Ever since learning about [Vercel][vercel] I have been looking for an excuse to use it for a project, and after deploying my personal blog
with it I can wholeheartedly say It's my new favourite way to deploy projects period. From pushing my GitRepo to having the site up and
running took literally minutes, it took me longer to remember my GoDaddy password than it did to get this site up and running.

Platforms like Vercel are really taking us into a golden age of one click deployments and near-instantaneous builds, and to say at present
this is all running on their incredible Free Tier which includes everything you need including automatic HTTPS/TLS certificates it's an
extremely impressive and compelling experience.

Vercel also excels at delivering your content as rapidly as possible, it's excellent caching and edge functions ensure your content is as
close to your users giving them an extremely performant experience.

![{{ "width": 440, "height": 248, "alt": "The Flash running", "caption": "How it feels running your site on Vercel" }}](/images/memes/flash-run.gif)

# Getting started

So without further delay, lets start talking about how I built this site. A lot of credit goes to Contentlayer's
excellent [getting started guide][contentlayer-getting-started], for which a lot of steps in this first post are going to be similar.

As I personally use [Yarn][yarn-getting-started] almost all of the examples shown will be using `yarn{:bash}` but all of the scripts will be
possible with your package manager of choice.

### 1. Create the Project

First step is to create a new NextJS project, the command below creates a new NextJS App called `next13-blog` in the current directory with
the following options:
- Enables TypeScript (I believe this might be the default now, but just to be safe)
- Configures Tailwind CSS
- Configures ESLint
- Enables the `app/{:text}` directory from NextJS 13
- Initializes NextJS with it's files in the `src/{:text}` directory (This is a personal preference as I think it's cleaner but you could leave this out)
- Configures an Import Alias of `~/*{:text}` that points to the `src/{:text}` directory (Again, personal preference)

```bash
yarn create next-app@latest --ts --tailwind --eslint --experimental-app --src-dir --import-alias "~/*" next13-blog
cd next13-blog
```

![{{ "width": 875, "height": 250, "alt": "Terminal Window showing Step 1", "caption": "Step 1. Create the Project" }}](/images/posts/nextjs/how-i-built-my-personal-blog-01/step1.webp)

> After that command completed, I did a few small tweaks to the project, these are changes that I always make to new NextJS Projects.
> I'm not going to create individual steps for them all as they don't directly relate to this example, but you can see the changes in f4a1a04

To prepare for the changes we are going to make, let's to remove some the default content created by `create-next-app` that we won't be needing:
- Delete `public/next.svg` and `public/vercel.svg`
- Delete `src/app/api/hello/route.ts`
- Delete `src/app/favicon.ico`
- Delete `src/app/page.tsx`

This should leave you with a clean starting point, and we can now continue.

### 2. Install Contentlayer

These next steps are to install and configure Contentlayer, first we need to install the required packages.

```bash
yarn add contentlayer next-contentlayer
```

Next we need to wrap our NextJS configuration with ContentLayer (`withContentLayer{:.fn}`), this allows Contentlayer to hook into NextJS's build
process to generate our content when we run commands such as `next dev{:text}` or `next build{:text}`:

```js title="next.config.js" showLineNumbers
const { withContentlayer } = require('next-contentlayer');

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true,
  },
  swcMinify: true,
};

module.exports = withContentlayer(nextConfig);
```

We then need to add a few lines into our `tsconfig.json{:text}` that allow the generated content files to be accessible within our code:

```json title="tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": ".",
    // ^^^^^^^^^^^^
    "paths": {
      "contentlayer/generated": ["./.contentlayer/generated"]
      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    }
  },
  "include": ["next-env.d.ts", "**/*.tsx", "**/*.ts", ".contentlayer/generated"]
  //                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
}
```

Contentlayer will generate files in the `.contentlayer/generated{:text}` directory. The lines tell TypeScript to create an alias
`contentlayer/generated{:text}` for us to access the generated files with.

Finally, we should add the `.contentlayer{:text}` to our `.gitignore{:text}` to ensure that built files aren't included in git.

### 3. Let's define our Post Schema

Now that everything is installed we need to define our configuration for Contentlayer. In this configuration we are going to define the schema
for the documents that make up out content. A document is an individual piece of content such as Markdown/MDX that will be transformed into
type-safe structured data that you can use in your components.

Because for this example we are just building a simple blog, we are going to define just a single document type called `Post{:text}`. To do
this we create a new file called `contentlayer.config.ts{:text}` in the root of our project, and we will add the following to it:

```ts title="contentlayer.config.ts" showLineNumbers
import { defineDocumentType, makeSource } from 'contentlayer/source-files';

export const Post = defineDocumentType(() => ({
  name: 'Post',
  filePathPattern: '**/*.md',
  fields: {
    title: {
      type: 'string',
      description: 'Title of the post',
      required: true,
    },
    publishedDate: {
      type: 'date',
      description: 'Date that the post was published',
      required: true,
    },
  },
  computedFields: {
    url: {
      type: 'string',
      resolve: (post) => `/posts/${post._raw.flattenedPath}`,
    },
  },
}));

export default makeSource({
  contentDirPath: 'posts',
  documentTypes: [Post],
});
```

This configuration file specifies a single document type called `Post{:text}` and it expects these documents to be `.md{:text}` files that
exist within a directory called `posts{:text}` in the root of your project. In the definition above we say that all objects generated from
these files will have the following properties:
- `title{:ts}` - String pulled from the documents [frontmatter][frontmatter].
- `publishedDate{:ts}` - JavaScript `Date{:.type}` object, pulled from the documents frontmatter.
- `url{:ts}` - A computed String that is the name of the file (without the extension) with `/posts/{:text}` prepended to it. This is used
  to define the path that your content will be available on within your site.

Finally there is also the `body{:ts}` which is included by Contentlayer by default, this is an object that contains the `raw{:ts}` content
from the Markdown files (just Markdown for now, we will look at MDX later) and the converted `html{:ts}` string.

### 4. Add your first Post

This of course doesn't actually need to be a proper post, you just need to add one or more `.md{:text}` files into the `posts{:text}`
directory and add some content into them. Here's an example of what a post file might look like with our example setup:

```md title="posts/post-01.md" showLineNumbers
---
title: The first
publishedDate: 2023-04-16
---

# Lorem

Lorem ipsum dolor sit amet consectetur, adipisicing elit. Eos ea nam tenetur nobis nisi necessitatibus ratione inventore quis
vitae odit hic quam, aspernatur facere expedita voluptas doloremque. Neque, quam commodi?
```

For the following examples, I have defined three posts `posts/post-01.md{:text}`, `posts/post-02.md{:text}` and `posts/post-03.md{:text}`
but you can of course call these anything you would like and fill them with anything you would like.

{/* Links */}
[nextjs-docs]: https://nextjs.org/docs
[nextjs-beta]: https://beta.nextjs.org/docs
[nextjs-beta-app]: https://beta.nextjs.org/docs/routing/fundamentals#the-app-directory
[contentlayer]: https://www.contentlayer.dev
[contentlayer-post]: https://www.contentlayer.dev/blog/working-with-content-is-hard-for-developers
[contentlayer-getting-started]: https://www.contentlayer.dev/docs/getting-started
[mdx]: https://mdxjs.com
[vercel]: https://vercel.com
[forbes-best-blogging-platforms]: https://www.forbes.com/advisor/business/software/best-blogging-platforms/
[my-medium-profile]: https://medium.com/@drbarnabus
[yarn-getting-started]: https://yarnpkg.com/getting-started
[frontmatter]: https://mdxjs.com/guides/frontmatter/
